"""
Python Universal Game Engine (Base version)
Author: Theodore Jackson
Description: Modular Python engine supporting physics, audio, rendering, input, and networking.
"""
import time
import math
import threading
import socket

# ============================================================
# Entity Class
# ============================================================
class Entity:
    def __init__(self, name, position=(0, 0, 0)):
        self.name = name
        self.position = list(position)
        self.velocity = [0, 0, 0]
        self.components = {}

    def add_component(self, component):
        comp_name = component.__class__.__name__
        self.components[comp_name] = component

    def update(self, delta):
        for comp in self.components.values():
            if hasattr(comp, 'update'):
                comp.update(self, delta)


# ============================================================
# Physics System
# ============================================================
class PhysicsSystem:
    def __init__(self, gravity=(0, -9.8, 0)):
        self.entities = []
        self.gravity = gravity

    def register(self, entity):
        self.entities.append(entity)

    def update(self, delta):
        for e in self.entities:
            # Apply gravity
            e.velocity[1] += self.gravity[1] * delta

            # Update position by velocity
            e.position = [p + v * delta for p, v in zip(e.position, e.velocity)]


# ============================================================
# Audio System (Placeholder - Modular Hook)
# ============================================================
class AudioSystem:
    def __init__(self):
        self.volume = 1.0

    def play_sound(self, name, pitch=1.0):
        print(f"[Audio] Playing: {name} (pitch={pitch:.2f}, volume={self.volume})")

    def update(self, entity, delta):
        pass  # Could link sound effects to entity velocity or collisions


# ============================================================
# Rendering System (Stub)
# ============================================================
class RenderSystem:
    def __init__(self):
        pass

    def draw(self, entities):
        for entity in entities:
            print(f"[Render] {entity.name} at {tuple(round(p, 2) for p in entity.position)}")


# ============================================================
# Input System (Stub)
# ============================================================
class InputSystem:
    def __init__(self):
        self.keys = set()

    def press_key(self, key):
        self.keys.add(key)

    def release_key(self, key):
        self.keys.discard(key)

    def is_pressed(self, key):
        return key in self.keys


# ============================================================
# Network System (Basic Client-Server Prototype)
# ============================================================
class NetworkSystem:
    def __init__(self, mode='server', host='127.0.0.1', port=9000):
        self.mode = mode
        self.host = host
        self.port = port
        self.active = True
        self.thread = None

    def start(self):
        if self.mode == 'server':
            self.thread = threading.Thread(target=self._run_server, daemon=True)
        else:
            self.thread = threading.Thread(target=self._run_client, daemon=True)
        self.thread.start()

    def _run_server(self):
        print(f"[Network] Server listening on {self.host}:{self.port}")
        s = socket.socket()
        s.bind((self.host, self.port))
        s.listen(1)
        conn, _ = s.accept()
        while self.active:
            data = conn.recv(1024).decode()
            if data:
                print(f"[Network] Received from client: {data}")

    def _run_client(self):
        print(f"[Network] Connecting to {self.host}:{self.port}")
        s = socket.socket()
        s.connect((self.host, self.port))
        while self.active:
            msg = input("Enter message: ")
            s.send(msg.encode())


# ============================================================
# Game Engine Core
# ============================================================
class GameEngine:
    def __init__(self):
        self.running = False
        self.entities = []
        self.physics = PhysicsSystem()
        self.audio = AudioSystem()
        self.render = RenderSystem()
        self.input = InputSystem()
        self.network = NetworkSystem(mode='server')

    def add_entity(self, entity):
        self.physics.register(entity)
        self.entities.append(entity)

    def start(self):
        self.running = True
        self.network.start()
        previous_time = time.time()
        print("[Engine] Starting main loop. Press CTRL+C to quit.")

        try:
            while self.running:
                now = time.time()
                delta = now - previous_time
                previous_time = now

                for entity in self.entities:
                    entity.update(delta)

                self.physics.update(delta)
                self.render.draw(self.entities)
                time.sleep(0.1)  # Simulate ~10 FPS loop
        except KeyboardInterrupt:
            print("[Engine] Shutting down.")
            self.running = False


# ============================================================
# Demo Usage
# ============================================================
if __name__ == "__main__":
    engine = GameEngine()

    car = Entity("Car", position=(0, 50, 0))
    car.velocity = [5, 0, 0]

    engine.add_entity(car)
    engine.start()
